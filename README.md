# Concurrent
java high concurrent

# 1.基本概念

**并发**：同时拥有两个或者多个线程如果程序在单核处理器上运行多个线程将交替地换入或者换出内存这些线程是同时“存在”的,每个线程都处于执行过程中的某个状态如果运行在多核处理器上,此时,程序中的每个线程都将分配到一个处理器核上,因此可以同时运行.

**高并发**：高并发( High Concurrency)是互联网分布式系统架构设计中必须考虑的因素之ー，它通常是指,通过设计保证系统能够同时并行处理很多请求.

**并发**：多个线程操作相同的姿源，保证线程安全，合理使用资源
**高并发**：服务能同时处理很多请求，提高程序性能

**cpu缓存**：

**为什么需要CPU缓存**：

CPU的频率太快了,快到主存跟不上,这样在处理器时钟周期内,CPU常常需要等待主存,浪费资源。
所以 cache的出现,是为了绶解CPU和内存之间速度的不匹配问题(结构:cpu-> cache-> memory)

**CPU缓存的意义**：

1)时间局部性:如果某个数据被访词,那么在不久的将来它很可能被再次访问
2)空间局部性:如果某个数据被访问,那么与它相邻的数据很快也可能被访问;

**CPU多级缓存的缓存一致性（MESI）**：

用于保证多个 PU cache之间缓存共享数据的一致

**CPU多级缓存-乱序执行优化**：

处理器为提高运算速度而做出违背代码原有顺序的优化。

**java内存模型**：

lock(锁定):作用于主内存的变量,把一个变量标识为一条线程独占状态
unlock(解锁):作用于主内存的变量,把一个处于锁定状态的变量释放出来,释放后的变量才可以被其他线程锁定
read(读取):作用于主内存的变量,把一个变量值从主内存传输到线程的工作内存中,以便随后的load动作使用
load(载入):作用于工作内存的变量,它把read操作从主內存中得到的变量值放入工作内存的变量副本中

use(使用):作用于工作内存的变量,把工作内存中的一个变量值传递给执行引擎
assign(赋值):作用于工作内存的变量,它把一个从执行引擎接收到的值赋值给工作内存的变量
store(存储):作用于工作内存的变量,把工作内存中的一个变量的值传送到主内存中,以便随后的 write的操作
write(写入):作用于主内存的变量,它把 store操作从工作内存中一个变量的值传送到主内存的变量中

同步规则：

如果要把一个变量从主内存中复制到工作内存,就需要按顺序地执行read和load操作,如果把变量从工作内存中同步回主内存中,就要按顺序地执行 store和 Write操作。但Java内存模型只要求上述操作必须按顺序执行,而没有保证必须是连续执行

不允许read和load、 store和 write操作之一单独出现

不允许一个线程丟弃它的最近 assign的操作,即变量在工作内存中改变了之后必须同步到主内存中

不允许一个线程无原因地(没有发生过任何 assign操作)把数据从工作内存同步回主内存中

一个新的变量只能在主内存中诞生,不允许在工作内存中直接使用一个未被初始化(load或 assign)的变量。即就是对一个变量实施use和 store操作之前,必须先执行过了 assign和load操作

一个变量在同一时刻只允许一条线程对其进行lock操作,但lock操作可以被同一条线程重复执行多次,多次执行lock后,只有执行相同次数的 unlock操作,変量才会被解锁。lock和 unlock必须成对出现

如果对一个变量执行lck操作,将会清空工作内存中此变量的值在执行引擎使用这个变量前需要重新执行load或 assign操作初始化变量的值

如果一个变量事先没有被lock操作锁定,则不允许对它执行unlock操作;也不允许去 unlockー个被其他线程锁定的变量

对一个变量执行 unlock操作之前,必须先把此变量同步到主内存中(执行 store和 write操作）

![1574065171489](assets/1574065171489.png)

![1574065569022](assets/1574065569022.png)

